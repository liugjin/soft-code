// Generated by IcedCoffeeScript 108.0.12
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(['underscore', "three", "OrbitControls", "CopyShader", "ShaderPass", "RenderPass", "SSAARenderPass", "AfterimagePass", "FXAAShader", "EffectComposer", "DRACOLoader", "GLTFLoader", "RGBELoader", "PMREMGenerator", "EquirectangularToCubeGenerator", "PMREMCubeUVPacker", "Water"], function(_, THREE) {
  var Scene;
  Scene = (function() {
    function Scene(dom) {
      this.changeBtn = __bind(this.changeBtn, this);
      this.height = dom.clientHeight;
      this.width = dom.clientWidth;
      this.status = false;
      this.initCamera();
      this.initScene();
      this.initLight();
      this.initRender();
      dom.appendChild(this.renderer.domElement);
      this.initComposer();
      this.loadFactoryModel();
      this.loadSeaModel();
      window.Scene = this.scene;
      this.render();
    }

    Scene.prototype.initCamera = function() {
      this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 10, 100000);
      this.camera.position.set(1000, 200, 0);
      this.controls = new THREE.OrbitControls(this.camera);
      this.controls.maxPolarAngle = Math.PI * 0.5;
      this.controls.minDistance = 10;
      this.controls.maxDistance = 3000;
      this.controls.target.set(0, 0, 0);
      this.controls.autoRotate = false;
      return this.controls.autoRotateSpeed = 2;
    };

    Scene.prototype.initScene = function() {
      var r, skytexture, urls;
      this.scene = new THREE.Scene();
      r = "static/asset/textures/sky4/";
      urls = [r + "posX.jpg", r + "negX.jpg", r + "posY.jpg", r + "negY.jpg", r + "posZ.jpg", r + "negZ.jpg"];
      skytexture = new THREE.CubeTextureLoader().load(urls);
      return this.scene.background = skytexture;
    };

    Scene.prototype.initLight = function() {
      var hemiLight;
      hemiLight = new THREE.HemisphereLight(0xc38e50, 0x111111, 0.1);
      hemiLight.position.set(0, 500, 0);
      this.scene.add(hemiLight);
      this.pointLight = new THREE.PointLight(0xffffff, 0.5);
      this.scene.add(this.pointLight);
      this.sunLight = new THREE.DirectionalLight(0xc38e50, 2.0);
      this.sunLight.position.set(-1000, 500, -1000);
      this.sunLight.castShadow = true;
      this.sunLight.shadow.mapSize.width = 1024;
      this.sunLight.shadow.mapSize.height = 1024;
      this.sunLight.shadow.camera.near = 10;
      this.sunLight.shadow.camera.far = 10000;
      this.sunLight.shadow.bias = -0.001;
      this.sunLight.shadow.camera.left = -900;
      this.sunLight.shadow.camera.right = 900;
      this.sunLight.shadow.camera.top = 900;
      this.sunLight.shadow.camera.bottom = -900;
      return this.scene.add(this.sunLight);
    };

    Scene.prototype.initRender = function() {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.width, this.height);
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      this.renderer.gammaInput = true;
      return this.renderer.gammaOutput = true;
    };

    Scene.prototype.initComposer = function() {
      var afterimagePass, effectFXAA, effectSSAA, renderScene;
      renderScene = new THREE.RenderPass(this.scene, this.camera);
      effectSSAA = new THREE.SSAARenderPass(this.scene, this.camera);
      effectSSAA.sampleLevel = 3;
      effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
      effectFXAA.uniforms.resolution.value.set(1 / this.width, 1 / this.height);
      afterimagePass = new THREE.AfterimagePass();
      this.composer = new THREE.EffectComposer(this.renderer);
      this.composer.setSize(this.width, this.height);
      this.composer.addPass(renderScene);
      this.composer.addPass(afterimagePass);
      return this.composer.addPass(effectFXAA);
    };

    Scene.prototype.loadFactoryModel = function() {
      var dracoLoader, gltfLoader, rgbeLoader;
      rgbeLoader = new THREE.RGBELoader().setDataType(THREE.UnsignedByteType).setPath('static/asset/textures/evMap/');
      dracoLoader = new THREE.DRACOLoader();
      dracoLoader.setDecoderPath("static/gltf/");
      gltfLoader = new THREE.GLTFLoader().setDRACOLoader(dracoLoader);
      return rgbeLoader.load("015.hdr", (function(_this) {
        return function(resp) {
          var generator, result, textureCube, uv;
          result = new THREE.EquirectangularToCubeGenerator(resp, {
            resolution: 1024
          });
          result.update(_this.renderer);
          generator = new THREE.PMREMGenerator(result.renderTarget.texture);
          generator.update(_this.renderer);
          uv = new THREE.PMREMCubeUVPacker(generator.cubeLods);
          uv.update(_this.renderer);
          textureCube = uv.CubeUVRenderTarget.texture;
          return gltfLoader.load("static/asset/models/scene/gongc.gltf", function(gltf) {
            var grounds;
            grounds = new THREE.Group();
            grounds.position.set(300, -45, 0);
            grounds.scale.set(0.01, 0.01, 0.01);
            grounds.rotation.set(0, 0, 0);
            gltf.scene.traverse(function(obj) {
              var child;
              if (!obj.isMesh) {
                return;
              }
              child = obj.clone();
              child.material.lightMap = child.material.aoMap;
              child.material.lightMapIntensity = 1.6;
              child.material.aoMapIntensity = 1.3;
              child.material.envMap = textureCube;
              child.material.side = THREE.DoubleSide;
              if (child.material.map !== null) {
                child.material.map.anisotropy = 8;
              }
              child.castShadow = true;
              child.receiveShadow = true;
              return grounds.add(child);
            });
            return _this.scene.add(grounds);
          });
        };
      })(this));
    };

    Scene.prototype.loadSeaModel = function() {
      var basic, waterGeometry;
      basic = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.1, 0.1));
      waterGeometry = new THREE.CircleBufferGeometry(30000, 30, 0, Math.PI * 2);
      return new THREE.TextureLoader().load("static/asset/textures/waternormals.jpg", (function(_this) {
        return function(resp) {
          resp.wrapS = THREE.RepeatWrapping;
          resp.wrapT = THREE.RepeatWrapping;
          _this.water = new THREE.Water(waterGeometry, {
            textureWidth: 1024,
            textureHeight: 1024,
            waterNormals: resp,
            alpha: 1.0,
            sunDirection: _this.sunLight.position.clone().normalize(),
            sunColor: 0xffdcb2,
            waterColor: 0x0f1d30,
            distortionScale: 5,
            fog: _this.scene.fog
          });
          _this.water.position.set(0, -50, 0);
          _this.water.rotation.x = -Math.PI * 0.5;
          basic.add(_this.water);
          return _this.scene.add(basic);
        };
      })(this));
    };

    Scene.prototype.render = function() {
      window.requestAnimationFrame(this.render.bind(this));
      this.pointLight.position.copy(this.camera.position);
      this.pointLight.scale.copy(this.camera.scale);
      if (this.water) {
        this.water.material.uniforms.time.value += 1.0 / 50.0;
      }
      this.controls.update();
      if (this.status) {
        return this.composer.render();
      } else {
        return this.renderer.render(this.scene, this.camera);
      }
    };

    Scene.prototype.changeBtn = function() {
      return this.status = !this.status;
    };

    return Scene;

  })();
  return Scene;
});
